---
layout: post
title: Django Day 2
---

### Review
Yesterday I learned how to create a practice project with a main `practice` app, created an `app` called `polls` to live in it, and set up what django terms a `url` and `view` within the polls app which returned a basic text response. Next up was to create a db, which in this case was sqlite3, and ensure the app config for the db was correct for what was being used. 

With that in place, I created models in the polls app and then registered the app by listing the it in the `INSTALLED_APPS` of the top level settings. The command `python manage.py makemigrations <app_name>` created a migration folder in the polls app with file (0001) detailing the changes.

### Data Models Continued
To start off today I learned that I can get a spiffy preview of the sql commands that the migration will generate by running `python manage.py sqlmigrate polls 0001`. 

`python manage.py check` will also run a check of the project without running any actual migrations.

It's time to actually update the database! This is the final step, first create models, then make the migrations, and finally migrate.

`python manage.py migrate` 

Just like rails, it runs all the migrations it can find, and applies them in order. The list of migrations and which are applied or not is maintained as an addtl table in the db.  
```py
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, polls, sessions
Running migrations:
  Applying polls.0001_initial... OK
```

### Using the Shell
`python manage.py shell` invokes the python shell. It is important to remember to use **manage.py**.

> We’re using this instead of simply typing “python”, because manage.py sets the DJANGO_SETTINGS_MODULE environment variable, which gives Django the Python import path to your app/settings.py file.

Once in the shell, it works similar to rails. I can import the model classes and interact with the db directly to perform crud operations. 

### Working with Models

#### String Method
Overriding string methods for properties on the model is a common practice. Not only can it make working with models much easier in the interactive shell, the admin feature will also represent those objects in their string form.

This example is from the docs. I am guessing in real life information such as the id might also be desired in the string representation of an model object.
```py
class Question(models.Model):
    # ...
    def __str__(self):
        return self.question_text
```

#### Custom Methods
Defining custom methods is exactly as expected on the model class. This example from the docs shows a simple method to determine if something was published in the last 24 hours or not. Note the use of timezone for a proper start date object.
```py
import datetime

from django.db import models
from django.utils import timezone


class Question(models.Model):
    # ...
    def was_published_recently(self):
        return self.pub_date >= timezone.now() - datetime.timedelta(days=1)
```

More reading [on timezones and django](https://docs.djangoproject.com/en/5.0/topics/i18n/timezones/).

### Querying Models and Relations
Django's API automatically follows model relations when interacting with models in the shell. Once I've imported the models into the shell, querying them and accessing the relations is a breeze. 

I'm sure I'll be getting to know this [page on referencing relations](https://docs.djangoproject.com/en/5.0/ref/models/relations/) quite well very soon.

### Django's Admin Module